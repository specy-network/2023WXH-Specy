// Generated by Ignite ignite.com/cli

import { StdFee } from "@cosmjs/launchpad";
import { SigningStargateClient, DeliverTxResponse } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { MsgLockAndSuperfluidDelegate } from "./types/osmosis/superfluid/tx";
import { MsgSuperfluidDelegate } from "./types/osmosis/superfluid/tx";
import { MsgCreateFullRangePositionAndSuperfluidDelegate } from "./types/osmosis/superfluid/tx";
import { MsgSuperfluidUndelegateAndUnbondLock } from "./types/osmosis/superfluid/tx";
import { MsgUnlockAndMigrateSharesToFullRangeConcentratedPosition } from "./types/osmosis/superfluid/tx";
import { MsgAddToConcentratedLiquiditySuperfluidPosition } from "./types/osmosis/superfluid/tx";
import { MsgSuperfluidUndelegate } from "./types/osmosis/superfluid/tx";
import { MsgSuperfluidUnbondLock } from "./types/osmosis/superfluid/tx";
import { MsgLockExistingFullRangePositionAndSFStake } from "./types/osmosis/superfluid/tx";
import { MsgUnPoolWhitelistedPool } from "./types/osmosis/superfluid/tx";

import { Params as typeParams} from "./types"
import { SuperfluidIntermediaryAccountInfo as typeSuperfluidIntermediaryAccountInfo} from "./types"
import { Delegations as typeDelegations} from "./types"
import { SuperfluidAsset as typeSuperfluidAsset} from "./types"
import { SuperfluidIntermediaryAccount as typeSuperfluidIntermediaryAccount} from "./types"
import { OsmoEquivalentMultiplierRecord as typeOsmoEquivalentMultiplierRecord} from "./types"
import { SuperfluidDelegationRecord as typeSuperfluidDelegationRecord} from "./types"
import { LockIdIntermediaryAccountConnection as typeLockIdIntermediaryAccountConnection} from "./types"
import { UnpoolWhitelistedPools as typeUnpoolWhitelistedPools} from "./types"
import { ConcentratedPoolUserPositionRecord as typeConcentratedPoolUserPositionRecord} from "./types"

export { MsgLockAndSuperfluidDelegate, MsgSuperfluidDelegate, MsgCreateFullRangePositionAndSuperfluidDelegate, MsgSuperfluidUndelegateAndUnbondLock, MsgUnlockAndMigrateSharesToFullRangeConcentratedPosition, MsgAddToConcentratedLiquiditySuperfluidPosition, MsgSuperfluidUndelegate, MsgSuperfluidUnbondLock, MsgLockExistingFullRangePositionAndSFStake, MsgUnPoolWhitelistedPool };

type sendMsgLockAndSuperfluidDelegateParams = {
  value: MsgLockAndSuperfluidDelegate,
  fee?: StdFee,
  memo?: string
};

type sendMsgSuperfluidDelegateParams = {
  value: MsgSuperfluidDelegate,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateFullRangePositionAndSuperfluidDelegateParams = {
  value: MsgCreateFullRangePositionAndSuperfluidDelegate,
  fee?: StdFee,
  memo?: string
};

type sendMsgSuperfluidUndelegateAndUnbondLockParams = {
  value: MsgSuperfluidUndelegateAndUnbondLock,
  fee?: StdFee,
  memo?: string
};

type sendMsgUnlockAndMigrateSharesToFullRangeConcentratedPositionParams = {
  value: MsgUnlockAndMigrateSharesToFullRangeConcentratedPosition,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddToConcentratedLiquiditySuperfluidPositionParams = {
  value: MsgAddToConcentratedLiquiditySuperfluidPosition,
  fee?: StdFee,
  memo?: string
};

type sendMsgSuperfluidUndelegateParams = {
  value: MsgSuperfluidUndelegate,
  fee?: StdFee,
  memo?: string
};

type sendMsgSuperfluidUnbondLockParams = {
  value: MsgSuperfluidUnbondLock,
  fee?: StdFee,
  memo?: string
};

type sendMsgLockExistingFullRangePositionAndSFStakeParams = {
  value: MsgLockExistingFullRangePositionAndSFStake,
  fee?: StdFee,
  memo?: string
};

type sendMsgUnPoolWhitelistedPoolParams = {
  value: MsgUnPoolWhitelistedPool,
  fee?: StdFee,
  memo?: string
};


type msgLockAndSuperfluidDelegateParams = {
  value: MsgLockAndSuperfluidDelegate,
};

type msgSuperfluidDelegateParams = {
  value: MsgSuperfluidDelegate,
};

type msgCreateFullRangePositionAndSuperfluidDelegateParams = {
  value: MsgCreateFullRangePositionAndSuperfluidDelegate,
};

type msgSuperfluidUndelegateAndUnbondLockParams = {
  value: MsgSuperfluidUndelegateAndUnbondLock,
};

type msgUnlockAndMigrateSharesToFullRangeConcentratedPositionParams = {
  value: MsgUnlockAndMigrateSharesToFullRangeConcentratedPosition,
};

type msgAddToConcentratedLiquiditySuperfluidPositionParams = {
  value: MsgAddToConcentratedLiquiditySuperfluidPosition,
};

type msgSuperfluidUndelegateParams = {
  value: MsgSuperfluidUndelegate,
};

type msgSuperfluidUnbondLockParams = {
  value: MsgSuperfluidUnbondLock,
};

type msgLockExistingFullRangePositionAndSFStakeParams = {
  value: MsgLockExistingFullRangePositionAndSFStake,
};

type msgUnPoolWhitelistedPoolParams = {
  value: MsgUnPoolWhitelistedPool,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendMsgLockAndSuperfluidDelegate({ value, fee, memo }: sendMsgLockAndSuperfluidDelegateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgLockAndSuperfluidDelegate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgLockAndSuperfluidDelegate({ value: MsgLockAndSuperfluidDelegate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgLockAndSuperfluidDelegate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSuperfluidDelegate({ value, fee, memo }: sendMsgSuperfluidDelegateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSuperfluidDelegate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgSuperfluidDelegate({ value: MsgSuperfluidDelegate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSuperfluidDelegate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateFullRangePositionAndSuperfluidDelegate({ value, fee, memo }: sendMsgCreateFullRangePositionAndSuperfluidDelegateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateFullRangePositionAndSuperfluidDelegate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgCreateFullRangePositionAndSuperfluidDelegate({ value: MsgCreateFullRangePositionAndSuperfluidDelegate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateFullRangePositionAndSuperfluidDelegate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSuperfluidUndelegateAndUnbondLock({ value, fee, memo }: sendMsgSuperfluidUndelegateAndUnbondLockParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSuperfluidUndelegateAndUnbondLock: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgSuperfluidUndelegateAndUnbondLock({ value: MsgSuperfluidUndelegateAndUnbondLock.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSuperfluidUndelegateAndUnbondLock: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUnlockAndMigrateSharesToFullRangeConcentratedPosition({ value, fee, memo }: sendMsgUnlockAndMigrateSharesToFullRangeConcentratedPositionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUnlockAndMigrateSharesToFullRangeConcentratedPosition: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUnlockAndMigrateSharesToFullRangeConcentratedPosition({ value: MsgUnlockAndMigrateSharesToFullRangeConcentratedPosition.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUnlockAndMigrateSharesToFullRangeConcentratedPosition: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddToConcentratedLiquiditySuperfluidPosition({ value, fee, memo }: sendMsgAddToConcentratedLiquiditySuperfluidPositionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddToConcentratedLiquiditySuperfluidPosition: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgAddToConcentratedLiquiditySuperfluidPosition({ value: MsgAddToConcentratedLiquiditySuperfluidPosition.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddToConcentratedLiquiditySuperfluidPosition: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSuperfluidUndelegate({ value, fee, memo }: sendMsgSuperfluidUndelegateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSuperfluidUndelegate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgSuperfluidUndelegate({ value: MsgSuperfluidUndelegate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSuperfluidUndelegate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSuperfluidUnbondLock({ value, fee, memo }: sendMsgSuperfluidUnbondLockParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSuperfluidUnbondLock: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgSuperfluidUnbondLock({ value: MsgSuperfluidUnbondLock.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSuperfluidUnbondLock: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgLockExistingFullRangePositionAndSFStake({ value, fee, memo }: sendMsgLockExistingFullRangePositionAndSFStakeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgLockExistingFullRangePositionAndSFStake: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgLockExistingFullRangePositionAndSFStake({ value: MsgLockExistingFullRangePositionAndSFStake.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgLockExistingFullRangePositionAndSFStake: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUnPoolWhitelistedPool({ value, fee, memo }: sendMsgUnPoolWhitelistedPoolParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUnPoolWhitelistedPool: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry, prefix});
				let msg = this.msgUnPoolWhitelistedPool({ value: MsgUnPoolWhitelistedPool.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUnPoolWhitelistedPool: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		msgLockAndSuperfluidDelegate({ value }: msgLockAndSuperfluidDelegateParams): EncodeObject {
			try {
				return { typeUrl: "/osmosis.superfluid.MsgLockAndSuperfluidDelegate", value: MsgLockAndSuperfluidDelegate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgLockAndSuperfluidDelegate: Could not create message: ' + e.message)
			}
		},
		
		msgSuperfluidDelegate({ value }: msgSuperfluidDelegateParams): EncodeObject {
			try {
				return { typeUrl: "/osmosis.superfluid.MsgSuperfluidDelegate", value: MsgSuperfluidDelegate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSuperfluidDelegate: Could not create message: ' + e.message)
			}
		},
		
		msgCreateFullRangePositionAndSuperfluidDelegate({ value }: msgCreateFullRangePositionAndSuperfluidDelegateParams): EncodeObject {
			try {
				return { typeUrl: "/osmosis.superfluid.MsgCreateFullRangePositionAndSuperfluidDelegate", value: MsgCreateFullRangePositionAndSuperfluidDelegate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateFullRangePositionAndSuperfluidDelegate: Could not create message: ' + e.message)
			}
		},
		
		msgSuperfluidUndelegateAndUnbondLock({ value }: msgSuperfluidUndelegateAndUnbondLockParams): EncodeObject {
			try {
				return { typeUrl: "/osmosis.superfluid.MsgSuperfluidUndelegateAndUnbondLock", value: MsgSuperfluidUndelegateAndUnbondLock.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSuperfluidUndelegateAndUnbondLock: Could not create message: ' + e.message)
			}
		},
		
		msgUnlockAndMigrateSharesToFullRangeConcentratedPosition({ value }: msgUnlockAndMigrateSharesToFullRangeConcentratedPositionParams): EncodeObject {
			try {
				return { typeUrl: "/osmosis.superfluid.MsgUnlockAndMigrateSharesToFullRangeConcentratedPosition", value: MsgUnlockAndMigrateSharesToFullRangeConcentratedPosition.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUnlockAndMigrateSharesToFullRangeConcentratedPosition: Could not create message: ' + e.message)
			}
		},
		
		msgAddToConcentratedLiquiditySuperfluidPosition({ value }: msgAddToConcentratedLiquiditySuperfluidPositionParams): EncodeObject {
			try {
				return { typeUrl: "/osmosis.superfluid.MsgAddToConcentratedLiquiditySuperfluidPosition", value: MsgAddToConcentratedLiquiditySuperfluidPosition.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddToConcentratedLiquiditySuperfluidPosition: Could not create message: ' + e.message)
			}
		},
		
		msgSuperfluidUndelegate({ value }: msgSuperfluidUndelegateParams): EncodeObject {
			try {
				return { typeUrl: "/osmosis.superfluid.MsgSuperfluidUndelegate", value: MsgSuperfluidUndelegate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSuperfluidUndelegate: Could not create message: ' + e.message)
			}
		},
		
		msgSuperfluidUnbondLock({ value }: msgSuperfluidUnbondLockParams): EncodeObject {
			try {
				return { typeUrl: "/osmosis.superfluid.MsgSuperfluidUnbondLock", value: MsgSuperfluidUnbondLock.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSuperfluidUnbondLock: Could not create message: ' + e.message)
			}
		},
		
		msgLockExistingFullRangePositionAndSFStake({ value }: msgLockExistingFullRangePositionAndSFStakeParams): EncodeObject {
			try {
				return { typeUrl: "/osmosis.superfluid.MsgLockExistingFullRangePositionAndSFStake", value: MsgLockExistingFullRangePositionAndSFStake.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgLockExistingFullRangePositionAndSFStake: Could not create message: ' + e.message)
			}
		},
		
		msgUnPoolWhitelistedPool({ value }: msgUnPoolWhitelistedPoolParams): EncodeObject {
			try {
				return { typeUrl: "/osmosis.superfluid.MsgUnPoolWhitelistedPool", value: MsgUnPoolWhitelistedPool.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUnPoolWhitelistedPool: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						Params: getStructure(typeParams.fromPartial({})),
						SuperfluidIntermediaryAccountInfo: getStructure(typeSuperfluidIntermediaryAccountInfo.fromPartial({})),
						Delegations: getStructure(typeDelegations.fromPartial({})),
						SuperfluidAsset: getStructure(typeSuperfluidAsset.fromPartial({})),
						SuperfluidIntermediaryAccount: getStructure(typeSuperfluidIntermediaryAccount.fromPartial({})),
						OsmoEquivalentMultiplierRecord: getStructure(typeOsmoEquivalentMultiplierRecord.fromPartial({})),
						SuperfluidDelegationRecord: getStructure(typeSuperfluidDelegationRecord.fromPartial({})),
						LockIdIntermediaryAccountConnection: getStructure(typeLockIdIntermediaryAccountConnection.fromPartial({})),
						UnpoolWhitelistedPools: getStructure(typeUnpoolWhitelistedPools.fromPartial({})),
						ConcentratedPoolUserPositionRecord: getStructure(typeConcentratedPoolUserPositionRecord.fromPartial({})),
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const Module = (test: IgniteClient) => {
	return {
		module: {
			OsmosisSuperfluid: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default Module;